<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>KenKen Builder & Solver</title>
  <style>
    body { font-family: sans-serif; text-align: center; }
    table { border-collapse: collapse; margin: 10px auto; }
    td {
      width: 50px; height: 50px; border: 1px solid #444;
      text-align: center; font-size: 20px; position: relative;
      cursor: pointer;
    }
    .selected { background: #cce5ff; }
    .cage-label {
      position: absolute; top: 0; left: 2px; font-size: 12px; color: #666;
    }
    input[type=number] { width: 60px; }
    button { margin: 5px; padding: 5px 10px; }
  </style>
</head>
<body>

<h2>KenKen Puzzle Builder & Solver</h2>

<label>Grid Size: <input id="sizeInput" type="number" value="5" min="3" max="9"></label>
<button onclick="buildGrid()">Build Grid</button>

<div id="editor" style="margin-top:10px;">
  <div>
    <label>Target: <input id="targetInput" type="number"></label>
    <label>Op: 
      <select id="opInput">
        <option>+</option><option>-</option><option>×</option><option>÷</option><option>=</option>
      </select>
    </label>
    <button onclick="addCage()">Add Cage</button>
  </div>
</div>

<table id="grid"></table>

<button onclick="solve()">Solve</button>

<script>
let size = 5;
let grid = [];
let cages = [];
let selectedCells = [];

function buildGrid() {
  size = parseInt(document.getElementById("sizeInput").value);
  const table = document.getElementById("grid");
  table.innerHTML = '';
  cages = [];
  selectedCells = [];
  grid = [];

  for (let r = 0; r < size; r++) {
    const tr = document.createElement("tr");
    const row = [];
    for (let c = 0; c < size; c++) {
      const td = document.createElement("td");
      td.dataset.row = r;
      td.dataset.col = c;
      td.addEventListener("click", () => toggleCell(td));
      tr.appendChild(td);
      row.push(td);
    }
    table.appendChild(tr);
    grid.push(row);
  }
}

function toggleCell(td) {
  const r = parseInt(td.dataset.row);
  const c = parseInt(td.dataset.col);
  const key = `${r},${c}`;
  if (selectedCells.some(cell => cell[0] === r && cell[1] === c)) {
    selectedCells = selectedCells.filter(cell => !(cell[0] === r && cell[1] === c));
    td.classList.remove("selected");
  } else {
    selectedCells.push([r, c]);
    td.classList.add("selected");
  }
}

function addCage() {
  const target = parseInt(document.getElementById("targetInput").value);
  const op = document.getElementById("opInput").value;
  if (!target || selectedCells.length === 0) return alert("Fill target and select cells");
  cages.push({ cells: [...selectedCells], target, op });
  selectedCells.forEach(([r, c], i) => {
    const td = grid[r][c];
    td.classList.remove("selected");
    if (i === 0) {
      const label = document.createElement("div");
      label.className = "cage-label";
      label.textContent = target + op;
      td.appendChild(label);
    }
  });
  selectedCells = [];
}

// Solver
function solve() {
  const board = Array.from({ length: size }, () => Array(size).fill(0));

  function isValid(r, c, val) {
    for (let i = 0; i < size; i++) {
      if (board[r][i] === val || board[i][c] === val) return false;
    }
    board[r][c] = val;
    for (const cage of cages) {
      const values = cage.cells.map(([x,y]) => board[x][y]).filter(v => v !== 0);
      if (values.length === cage.cells.length) {
        const res = evalCage(values, cage.op);
        if (res !== cage.target) {
          board[r][c] = 0;
          return false;
        }
      } else if (cage.op === '=' && values[0] && values[0] !== cage.target) {
        board[r][c] = 0;
        return false;
      }
    }
    board[r][c] = 0;
    return true;
  }

  function evalCage(values, op) {
    if (op === '+') return values.reduce((a,b)=>a+b, 0);
    if (op === '-') return Math.abs(values[0] - values[1]);
    if (op === '×') return values.reduce((a,b)=>a*b, 1);
    if (op === '÷') return Math.max(...values) / Math.min(...values);
    if (op === '=') return values[0];
  }

  function backtrack(r = 0, c = 0) {
    if (r === size) return true;
    const [nextR, nextC] = c === size - 1 ? [r + 1, 0] : [r, c + 1];
    for (let val = 1; val <= size; val++) {
      if (isValid(r, c, val)) {
        board[r][c] = val;
        if (backtrack(nextR, nextC)) return true;
        board[r][c] = 0;
      }
    }
    return false;
  }

  if (backtrack()) {
    for (let r = 0; r < size; r++) {
      for (let c = 0; c < size; c++) {
        grid[r][c].textContent = board[r][c];
      }
    }
  } else {
    alert("No solution found.");
  }
}

// Build initial 5x5
buildGrid();
</script>

</body>
</html>
