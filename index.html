<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>KenKen Builder • OCR Import • Solver</title>
    <style>
        body { font-family: sans-serif; text-align: center; margin: 20px; }
        table { border-collapse: collapse; margin: 10px auto; }
        td {
            width: 50px; height: 50px;
            text-align: center; font-size: 20px; position: relative;
            cursor: pointer; padding: 0;
            box-sizing: border-box; /* Include padding/border in width/height */
        }
        .selected { background: #cce5ff; }
        .cage-label {
            position: absolute;
            top: 0; left: 2px;
            font-size: 12px;
            color: #666;
            pointer-events: none; /* Allow clicks to pass through to cell */
            z-index: 1; /* Ensure label is above content */
        }
        .op-button {
            padding: 5px 10px;
            margin: 2px;
            font-size: 16px;
            cursor: pointer;
        }
        .op-button.selected {
            background-color: #007bff;
            color: white;
            border: none;
        }
        input[type=number] { width: 60px; }
        button { margin: 5px; padding: 5px 10px; }
        #preview { max-width: 300px; max-height: 300px; margin-top: 10px; border: 1px solid #aaa; display: block; margin-left: auto; margin-right: auto;}
        #outputCanvas { max-width: 300px; max-height: 300px; margin-top: 10px; border: 1px solid #aaa; display: block; margin-left: auto; margin-right: auto; }
        #progressBox { width: 300px; margin: 10px auto; border: 1px solid #666; height: 16px; position: relative; }
        #bar { height: 100%; width: 0; background: #28a745; text-align: center; color: white; font-size: 10px; line-height: 16px; }
    </style>
    <script src="https://docs.opencv.org/4.x/opencv.js" async onload="cvReadyCallback()"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
</head>
<body>

    <h2>KenKen Builder · Screenshot Importer · Solver</h2>

    <label>Grid Size <input id="sizeInput" type="number" value="6" min="3" max="25"></label>
    <button onclick="buildGrid()">Build Grid</button>

    <div id="editor" style="margin-top:10px">
        <label>Target <input id="targetInput" type="number"></label>
        <span>Operator:</span>
        <button class="op-button" onclick="selectOp(this,'+')">+</button>
        <button class="op-button" onclick="selectOp(this,'-')">-</button>
        <button class="op-button" onclick="selectOp(this,'×')">×</button>
        <button class="op-button" onclick="selectOp(this,'÷')">÷</button>
        <button class="op-button" onclick="selectOp(this,'=')">=</button>
        <button onclick="addCage()">Add Cage</button>
    </div>

    <hr>
    <h3>Import a Screenshot</h3>
    <input type="file" id="imgInput" accept="image/*">
    <br><img id="preview" alt="Image Preview">
    <canvas id="outputCanvas"></canvas> <div id="progressBox" style="display:none"><div id="bar"></div></div>
    <p><button id="importBtn" disabled onclick="importImage()">Import This Image</button></p>

    <table id="grid"></table>
    <button onclick="solve()">Solve</button>

    <script>
        let cvReady = false, tessReady = false, tessWorker = null;
        let size = 6, grid = [], cages = [], selectedCells = [], selectedOp = null;
        let initialBoardState = []; // To store numbers extracted by OCR

        // --- Library Initialization ---
        function cvReadyCallback() {
            cvReady = true;
            console.log("OpenCV is ready!");
            checkReady();
        }

        (async () => {
            tessWorker = Tesseract.createWorker({
                logger: m => {
                    // console.log(m); // Uncomment for detailed Tesseract logs
                    // Only update progress bar during actual import, not initial loading
                    // if (m.status === 'recognizing text' || m.status === 'initializing Tesseract' || m.status === 'loading tesseract core' || m.status === 'loading language traineddata') {
                    //     setBar(m.progress * 100, `Tesseract: ${m.status}`);
                    // }
                }
            });
            await tessWorker.load();
            await tessWorker.loadLanguage('eng');
            await tessWorker.initialize('eng');
            tessReady = true;
            console.log("Tesseract is ready!");
            checkReady();
        })();

        // --- Global Readiness Check ---
        function checkReady() {
            if (cvReady && tessReady) {
                document.getElementById('importBtn').disabled = false;
                console.log("All libraries (OpenCV, Tesseract) are ready. Import button enabled!");
            }
        }

        // --- KenKen Builder (Manual Input) Logic ---
        document.addEventListener('DOMContentLoaded', buildGrid); // Build grid on page load

        function buildGrid() {
            size = parseInt(document.getElementById("sizeInput").value);
            const table = document.getElementById("grid");
            table.innerHTML = '';
            cages = []; selectedCells = []; selectedOp = null; clearOpButtons();
            grid = []; // Reset internal grid reference
            initialBoardState = Array(size).fill(0).map(() => Array(size).fill(0)); // Reset initial numbers

            for (let r = 0; r < size; r++) {
                const tr = document.createElement("tr");
                const row = [];
                for (let c = 0; c < size; c++) {
                    const td = document.createElement("td");
                    td.dataset.row = r;
                    td.dataset.col = c;
                    td.addEventListener("click", () => toggleCell(td));
                    td.textContent = '';
                    tr.appendChild(td);
                    row.push(td);
                }
                table.appendChild(tr);
                grid.push(row);
            }
            refreshGrid(); // Apply default borders and clear content
        }

        function toggleCell(td) {
            const r = parseInt(td.dataset.row);
            const c = parseInt(td.dataset.col);
            const i = selectedCells.findIndex(cell => cell[0] === r && cell[1] === c);
            if (i >= 0) {
                selectedCells.splice(i, 1);
                td.classList.remove("selected");
            } else {
                selectedCells.push([r, c]);
                td.classList.add("selected");
            }
        }

        function selectOp(button, op) {
            selectedOp = op;
            clearOpButtons();
            button.classList.add("selected");
        }

        function clearOpButtons() {
            document.querySelectorAll('.op-button').forEach(btn => {
                btn.classList.remove("selected");
            });
        }

        function addCage() {
            const targetInput = document.getElementById("targetInput").value;
            const target = parseInt(targetInput);

            if (selectedCells.length === 0) {
                alert("Please select cells for the cage.");
                return;
            }
            if (!selectedOp) {
                alert("Please select an operator.");
                return;
            }
            if (selectedOp !== '=' && (!targetInput || isNaN(target))) {
                alert("Please enter a valid target number for the cage, or select '=' for single-cell cages.");
                return;
            }

            const currentCageCells = [...selectedCells]; // Create a copy

            // Overwrite any existing cage that overlaps
            const newSet = new Set(currentCageCells.map(c => c + ""));
            cages = cages.filter(c => !c.cells.some(cell => newSet.has(cell + "")));

            // Sort cells for consistent cage representation
            currentCageCells.sort((a, b) => a[0] - b[0] || a[1] - b[1]);

            cages.push({ cells: currentCageCells, target: targetInput, op: selectedOp });

            selectedCells = [];
            document.getElementById("targetInput").value = '';
            clearOpButtons();
            selectedOp = null;
            refreshGrid();
        }

        function refreshGrid() {
            // Clear all visual aspects and reset content based on initialBoardState
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    const td = grid[r][c];
                    td.classList.remove("selected");
                    td.textContent = initialBoardState[r][c] !== 0 ? initialBoardState[r][c] : ''; // Re-apply initial numbers
                    td.querySelector(".cage-label")?.remove();
                    td.style.border = "1px solid #444"; // Reset to default thin border
                }
            }

            // Apply cage labels based on the cages array
            cages.forEach((cage) => {
                // Find the top-leftmost cell in the cage for the label
                if (cage.cells.length > 0) {
                    const [topmostR, leftmostC] = cage.cells.reduce((minCell, currentCell) => {
                        if (currentCell[0] < minCell[0]) return currentCell;
                        if (currentCell[0] === minCell[0] && currentCell[1] < minCell[1]) return currentCell;
                        return minCell;
                    }, cage.cells[0]);

                    const td = grid[topmostR][leftmostC];
                    let label = td.querySelector(".cage-label");
                    if (!label) {
                        label = document.createElement("div");
                        label.className = "cage-label";
                        td.appendChild(label);
                    }
                    label.textContent = cage.target + cage.op;
                }
            });
            updateCageBorders(); // Update borders based on cages array
        }

        function getCageIndex(r, c) {
            for (let i = 0; i < cages.length; i++) {
                if (cages[i].cells.some(([x, y]) => x === r && y === c)) return i;
            }
            return null;
        }

        function updateCageBorders() {
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    const td = grid[r][c];
                    const thisCage = getCageIndex(r, c);

                    // Reset borders to default first
                    td.style.borderTop = '1px solid #444';
                    td.style.borderLeft = '1px solid #444';
                    td.style.borderBottom = '1px solid #444';
                    td.style.borderRight = '1px solid #444';

                    if (thisCage === null) {
                        continue;
                    }

                    // Apply thicker black border if cell is on a cage boundary
                    const top = (r > 0 && getCageIndex(r - 1, c) !== thisCage) ? '2px solid black' : '1px solid #444';
                    const left = (c > 0 && getCageIndex(r, c - 1) !== thisCage) ? '2px solid black' : '1px solid #444';
                    const bottom = (r < size - 1 && getCageIndex(r + 1, c) !== thisCage) ? '2px solid black' : '1px solid #444';
                    const right = (c < size - 1 && getCageIndex(r, c + 1) !== thisCage) ? '2px solid black' : '1px solid #444';

                    td.style.borderTop = top;
                    td.style.borderLeft = left;
                    td.style.borderBottom = bottom;
                    td.style.borderRight = right;
                }
            }
        }

        // --- KenKen Solver Logic ---
        function solve() {
            const board = initialBoardState.map(row => [...row]); // Start with pre-filled numbers

            function isValid(r, c, val) {
                // Check row and column for duplicates
                for (let i = 0; i < size; i++) {
                    if (board[r][i] === val || board[i][c] === val) return false;
                }

                // Temporarily place the value to check cage constraints
                board[r][c] = val;

                for (const cage of cages) {
                    const isCellInCage = cage.cells.some(([cx, cy]) => cx === r && cy === c);
                    if (!isCellInCage) continue;

                    const valuesInCage = cage.cells.map(([x, y]) => board[x][y]).filter(v => v !== 0);

                    // Check if all cells in the cage are filled, then evaluate the full cage constraint
                    if (valuesInCage.length === cage.cells.length) {
                        const result = evaluate(valuesInCage, cage.op); // target is used inside evaluate
                        if (result === null || result !== parseInt(cage.target)) { // Compare with cage's target
                            board[r][c] = 0;
                            return false;
                        }
                    } else {
                        // Pruning for partial cages
                        if (cage.op === '=' && valuesInCage.length === 1 && valuesInCage[0] !== parseInt(cage.target)) {
                            board[r][c] = 0;
                            return false;
                        }
                        if (cage.op === '+' && valuesInCage.reduce((a, b) => a + b, 0) > parseInt(cage.target)) {
                            board[r][c] = 0; return false;
                        }
                        if (cage.op === '×' && valuesInCage.reduce((a, b) => a * b, 1) > parseInt(cage.target)) {
                            board[r][c] = 0; return false;
                        }
                        // For division/subtraction, cannot prune easily until both cells are filled
                        // unless specific rules apply, like values exceeding target with only 1 cell.
                    }
                }

                board[r][c] = 0; // Backtrack temporary placement
                return true;
            }

            function evaluate(values, op) {
                // Ensure values are numbers
                values = values.map(Number);

                if (op === '+') return values.reduce((a, b) => a + b, 0);
                if (op === '-') {
                    if (values.length === 2) return Math.abs(values[0] - values[1]);
                    return null; // Invalid for non-2 cell subtraction
                }
                if (op === '×') return values.reduce((a, b) => a * b, 1);
                if (op === '÷') {
                    if (values.length === 2) {
                        const maxVal = Math.max(...values);
                        const minVal = Math.min(...values);
                        if (minVal === 0 || maxVal % minVal !== 0) return null; // Avoid division by zero or non-integer results
                        return maxVal / minVal;
                    }
                    return null; // Invalid for non-2 cell division
                }
                if (op === '=') return values[0];
                return null;
            }

            function backtrack(r = 0, c = 0) {
                // Find next empty cell
                while (r < size && board[r][c] !== 0) {
                    if (c === size - 1) {
                        r++;
                        c = 0;
                    } else {
                        c++;
                    }
                }

                if (r === size) return true; // All rows filled, puzzle solved

                for (let val = 1; val <= size; val++) {
                    if (isValid(r, c, val)) {
                        board[r][c] = val;
                        if (backtrack(r, c)) return true;
                        board[r][c] = 0; // Backtrack
                    }
                }
                return false;
            }

            // Start the solver
            if (backtrack()) {
                for (let r = 0; r < size; r++) {
                    for (let c = 0; c < size; c++) {
                        grid[r][c].textContent = board[r][c];
                    }
                }
                alert("Solution found!");
            } else {
                alert("No solution found for this KenKen puzzle.");
            }
        }

        // --- Image Import and Processing Logic (OCR Input) ---
        function setBar(pct, message = '') {
            const progressBox = document.getElementById('progressBox');
            const bar = document.getElementById('bar');
            progressBox.style.display = 'block';
            bar.style.width = pct + '%';
            bar.textContent = message;
        }

        document.getElementById('imgInput').onchange = e => {
            const file = e.target.files[0];
            if (!file) return;
            const preview = document.getElementById('preview');
            preview.src = URL.createObjectURL(file);
            preview.onload = () => {
                URL.revokeObjectURL(preview.src);
                document.getElementById('outputCanvas').style.display = 'none'; // Hide output canvas initially
            };
        };

        async function importImage() {
            const imgElement = document.getElementById('preview');
            if (!imgElement.src || imgElement.src.startsWith('blob:null')) {
                alert("Please select an image first for import.");
                return;
            }

            setBar(0, 'Initializing image processing...');
            document.getElementById('progressBox').style.display = 'block';
            document.getElementById('outputCanvas').style.display = 'block'; // Show canvas for output

            let src = null, gray = null, processed = null, lines = null, dst = null; // Declare Mats for cleanup

            try {
                // 1. Load image and preprocess
                setBar(5, 'Loading image...');
                src = cv.imread(imgElement);
                gray = new cv.Mat();
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);

                setBar(10, 'Applying adaptive threshold...');
                processed = new cv.Mat();
                cv.adaptiveThreshold(gray, processed, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 2);

                // 2. Find lines using HoughLinesP
                setBar(20, 'Detecting lines (Hough Transform)...');
                lines = new cv.Mat();
                cv.HoughLinesP(processed, lines, 1, Math.PI / 180, 50, 40, 5); // threshold, minLineLength, maxLineGap

                // 3. Filter and cluster lines to identify major grid lines
                setBar(30, 'Clustering grid lines...');
                let horizontalLines = [];
                let verticalLines = [];
                const angleTolerance = 5 * Math.PI / 180; // +/- 5 degrees tolerance
                const lineClusteringTolerance = 10; // Pixels for clustering nearby lines

                for (let i = 0; i < lines.rows; ++i) {
                    let x1 = lines.data32S[i * 4];
                    let y1 = lines.data32S[i * 4 + 1];
                    let x2 = lines.data32S[i * 4 + 2];
                    let y2 = lines.data32S[i * 4 + 3];

                    let angle = Math.atan2(y2 - y1, x2 - x1);

                    if (Math.abs(angle) < angleTolerance || Math.abs(angle - Math.PI) < angleTolerance) { // Horizontal
                        horizontalLines.push(Math.round((y1 + y2) / 2));
                    } else if (Math.abs(angle - Math.PI / 2) < angleTolerance || Math.abs(angle + Math.PI / 2) < angleTolerance) { // Vertical
                        verticalLines.push(Math.round((x1 + x2) / 2));
                    }
                }

                function clusterLines(linePositions, tolerance) {
                    linePositions.sort((a, b) => a - b);
                    let clustered = [];
                    if (linePositions.length === 0) return clustered;

                    let currentCluster = [linePositions[0]];
                    for (let i = 1; i < linePositions.length; i++) {
                        if (linePositions[i] - currentCluster[currentCluster.length - 1] < tolerance) {
                            currentCluster.push(linePositions[i]);
                        } else {
                            clustered.push(Math.round(currentCluster.reduce((a, b) => a + b, 0) / currentCluster.length));
                            currentCluster = [linePositions[i]];
                        }
                    }
                    clustered.push(Math.round(currentCluster.reduce((a, b) => a + b, 0) / currentCluster.length));
                    return clustered;
                }

                let uniqueH = clusterLines(horizontalLines, lineClusteringTolerance);
                let uniqueV = clusterLines(verticalLines, lineClusteringTolerance);

                console.log("Detected Horizontal Lines (Y-coords):", uniqueH);
                console.log("Detected Vertical Lines (X-coords):", uniqueV);

                // Determine grid size
                if (uniqueH.length < 2 || uniqueV.length < 2) {
                    throw new Error("Could not detect enough grid lines. Ensure image is clear and well-aligned.");
                }
                const detectedSize = Math.min(uniqueH.length - 1, uniqueV.length - 1);
                if (detectedSize < 3 || detectedSize > 25) {
                    throw new Error(`Detected grid size ${detectedSize} is out of typical KenKen range (3-25).`);
                }
                size = detectedSize; // Update global size
                document.getElementById('sizeInput').value = size; // Update UI

                // Initialize internal state variables for the new grid size
                cages = [];
                initialBoardState = Array(size).fill(0).map(() => Array(size).fill(0));


                // 4. Determine cell coordinates
                setBar(40, 'Mapping cell coordinates...');
                const cellCoords = [];
                for (let r = 0; r < size; r++) {
                    for (let c = 0; c < size; c++) {
                        const x1 = uniqueV[c];
                        const y1 = uniqueH[r];
                        const x2 = uniqueV[c + 1];
                        const y2 = uniqueH[r + 1];
                        cellCoords.push({ r, c, x: x1, y: y1, width: x2 - x1, height: y2 - y1 });
                    }
                }

                // 5. Create a border map by analyzing pixel density along cell edges in `processed` image
                setBar(50, 'Analyzing cell borders...');
                const borderMap = Array(size).fill(0).map(() => Array(size).fill(0).map(() => ({
                    top: false, bottom: false, left: false, right: false
                })));

                // Threshold for line pixel density (tune this value based on line thickness in your image)
                // A higher value means it needs more white pixels (from BINARY_INV) to be considered a border.
                const lineDensityThreshold = 0.5; // e.g., 50% of pixels along segment must be white (line)
                const lineCheckWidth = 5; // Pixels to check perpendicular to the line for density (to account for line thickness)

                for (let r = 0; r < size; r++) {
                    for (let c = 0; c < size; c++) {
                        const cell = cellCoords.find(coord => coord.r === r && coord.c === c);
                        if (!cell) continue;

                        // Function to check pixel density along a line segment
                        const checkLineSegment = (x_start, y_start, x_end, y_end, isHorizontal) => {
                            let linePixels = 0;
                            let totalPixels = 0;

                            if (isHorizontal) {
                                for (let x = x_start; x < x_end; x++) {
                                    // Check a small vertical strip around the line to account for thickness
                                    for (let dy = -Math.floor(lineCheckWidth/2); dy <= Math.ceil(lineCheckWidth/2); dy++) {
                                        const checkY = y_start + dy;
                                        if (checkY >= 0 && checkY < processed.rows && x >= 0 && x < processed.cols) {
                                            totalPixels++;
                                            if (processed.data[checkY * processed.cols + x] === 255) { // Is it a white pixel (part of a line)?
                                                linePixels++;
                                            }
                                        }
                                    }
                                }
                            } else { // Vertical
                                for (let y = y_start; y < y_end; y++) {
                                    // Check a small horizontal strip around the line
                                    for (let dx = -Math.floor(lineCheckWidth/2); dx <= Math.ceil(lineCheckWidth/2); dx++) {
                                        const checkX = x_start + dx;
                                        if (checkX >= 0 && checkX < processed.cols && y >= 0 && y < processed.rows) {
                                            totalPixels++;
                                            if (processed.data[y * processed.cols + checkX] === 255) {
                                                linePixels++;
                                            }
                                        }
                                    }
                                }
                            }
                            return totalPixels > 0 ? (linePixels / totalPixels) : 0;
                        };


                        // Check top border
                        if (r > 0) { // Only for internal horizontal lines
                            const density = checkLineSegment(cell.x, cell.y, cell.x + cell.width, cell.y, true);
                            if (density > lineDensityThreshold) {
                                borderMap[r][c].top = true;
                                borderMap[r-1][c].bottom = true;
                            }
                        }

                        // Check left border
                        if (c > 0) { // Only for internal vertical lines
                            const density = checkLineSegment(cell.x, cell.y, cell.x, cell.y + cell.height, false);
                            if (density > lineDensityThreshold) {
                                borderMap[r][c].left = true;
                                borderMap[r][c-1].right = true;
                            }
                        }
                        // Outer borders are handled by the fact that the first row has no top, last no bottom, etc.
                    }
                }
                console.log("Border Map (derived from pixel density):", borderMap);

                // 6. Perform OCR on the entire image for all text/words
                setBar(70, 'Performing OCR on image...');
                // We are passing imgElement (the original image) directly to Tesseract
                // The logger for Tesseract is already configured globally
                const { data: { words: allWords } } = await tessWorker.recognize(imgElement);
                console.log("All Recognized Words with BBoxes:", allWords);

                // 7. Map OCR words to grid cells and parse cage labels/numbers
                setBar(80, 'Mapping OCR results to grid cells...');
                const cellContents = Array(size).fill(0).map(() => Array(size).fill(0).map(() => ({ labels: [], numbers: [] })));

                for (const word of allWords) {
                    const wordRect = word.bbox;
                    for (const cell of cellCoords) {
                        // Check if the center of the word's bounding box falls within the cell
                        const wordCenterX = wordRect.x0 + wordRect.width / 2;
                        const wordCenterY = wordRect.y0 + wordRect.height / 2;

                        if (wordCenterX >= cell.x && wordCenterX <= cell.x + cell.width &&
                            wordCenterY >= cell.y && wordCenterY <= cell.y + cell.height) {

                            const parsed = parseCageLabel(word.text.trim());
                            const num = parseInt(word.text.trim());

                            if (parsed.op && (parsed.target !== null || parsed.op === '=')) {
                                cellContents[cell.r][cell.c].labels.push({ text: word.text.trim(), parsed: parsed, bbox: wordRect });
                            }
                            // Store number if valid AND it's a single number (not part of a label like "8+")
                            // A simple check: if the label parser found an operator, it's a label, not a solitary number.
                            if (!isNaN(num) && num >= 1 && num <= size && !parsed.op) {
                                initialBoardState[cell.r][cell.c] = num; // Pre-fill numbers directly
                            }
                            break; // Word found its cell
                        }
                    }
                }
                console.log("Cell Contents (from OCR mapping):", cellContents);

                // 8. Reconstruct Cages using Flood Fill and Border Map
                setBar(90, 'Reconstructing cages...');
                const visitedCellsForCages = Array(size).fill(false).map(() => Array(size).fill(false));
                cages = []; // Clear global cages array

                function floodFillForCage(startR, startC, cellCoordsMap, borderMap, visited) {
                    const cageCells = [];
                    const queue = [[startR, startC]];
                    visited[startR][startC] = true;

                    while (queue.length > 0) {
                        const [currR, currC] = queue.shift();
                        cageCells.push([currR, currC]);

                        // Check neighbors: Up, Down, Left, Right
                        const neighbors = [
                            { dr: -1, dc: 0, dir: 'top', oppDir: 'bottom' }, // Up
                            { dr: 1, dc: 0, dir: 'bottom', oppDir: 'top' }, // Down
                            { dr: 0, dc: -1, dir: 'left', oppDir: 'right' }, // Left
                            { dr: 0, dc: 1, dir: 'right', oppDir: 'left' }  // Right
                        ];

                        for (const { dr, dc, dir, oppDir } of neighbors) {
                            const nr = currR + dr;
                            const nc = currC + dc;

                            if (nr >= 0 && nr < size && nc >= 0 && nc < size && !visited[nr][nc]) {
                                // Check if there's a thick border between (currR, currC) and (nr, nc)
                                const hasBorder = borderMap[currR][currC][dir]; // Check current cell's border to neighbor

                                if (!hasBorder) { // If NO border, add to queue
                                    queue.push([nr, nc]);
                                    visited[nr][nc] = true;
                                }
                            }
                        }
                    }
                    return cageCells;
                }

                for (let r = 0; r < size; r++) {
                    for (let c = 0; c < size; c++) {
                        if (cellContents[r][c].labels.length > 0 && !visitedCellsForCages[r][c]) {
                            const label = cellContents[r][c].labels[0]; // Take the first label
                            const { target: cageTarget, op: cageOp } = label.parsed;

                            if (cageTarget !== null || cageOp === '=') { // Ensure it's a valid cage label
                                const cellsInThisCage = floodFillForCage(r, c, cellCoords, borderMap, visitedCellsForCages);

                                if (cellsInThisCage.length > 0) {
                                    cellsInThisCage.sort((a, b) => a[0] - b[0] || a[1] - b[1]);
                                    cages.push({ cells: cellsInThisCage, target: cageTarget, op: cageOp });
                                }
                            }
                        }
                    }
                }
                console.log("Reconstructed Cages (robust):", cages);
                console.log("Initial Board State (from OCR numbers):", initialBoardState);

                // 9. Update UI with reconstructed grid and cages
                // Preserve OCR-detected values as buildGrid() will reset global state
                const currentSizeVal = size;
                const currentCages = [...cages];
                const currentInitialBoardState = initialBoardState.map(row => [...row]);

                // Reset grid UI based on the new size
                document.getElementById('sizeInput').value = currentSizeVal;
                buildGrid(); // This recreates the HTML table and resets internal arrays (cages, initialBoardState)

                // Restore OCR-detected values
                size = currentSizeVal;
                cages = currentCages;
                initialBoardState = currentInitialBoardState;

                refreshGrid(); // Redraw with imported data

                // Visual confirmation on outputCanvas
                dst = cv.imread(imgElement); // Reload original image
                // Draw detected grid lines (thin green)
                for (let i = 0; i < uniqueH.length; i++) {
                    cv.line(dst, new cv.Point(uniqueV[0], uniqueH[i]), new cv.Point(uniqueV[uniqueV.length - 1], uniqueH[i]), new cv.Scalar(0, 255, 0, 255), 1);
                }
                for (let i = 0; i < uniqueV.length; i++) {
                    cv.line(dst, new cv.Point(uniqueV[i], uniqueH[0]), new cv.Point(uniqueV[i], uniqueH[uniqueH.length - 1]), new cv.Scalar(0, 255, 0, 255), 1);
                }
                // Draw thick red borders from the borderMap
                for (let r = 0; r < size; r++) {
                    for (let c = 0; c < size; c++) {
                        const cell = cellCoords.find(coord => coord.r === r && coord.c === c);
                        if (!cell) continue;

                        if (borderMap[r][c].top) {
                            cv.line(dst, new cv.Point(cell.x, cell.y), new cv.Point(cell.x + cell.width, cell.y), new cv.Scalar(255, 0, 0, 255), 3);
                        }
                        if (borderMap[r][c].left) {
                            cv.line(dst, new cv.Point(cell.x, cell.y), new cv.Point(cell.x, cell.y + cell.height), new cv.Scalar(255, 0, 0, 255), 3);
                        }
                        // Only draw bottom/right for the last row/col or if it's an outer border
                        // This prevents drawing internal lines twice.
                        if (r === size - 1 && !borderMap[r][c].bottom) { // Last row, no internal bottom border
                             cv.line(dst, new cv.Point(cell.x, cell.y + cell.height), new cv.Point(cell.x + cell.width, cell.y + cell.height), new cv.Scalar(0, 0, 255, 255), 3); // Blue outer
                        } else if (borderMap[r][c].bottom) { // Internal thick bottom border
                            cv.line(dst, new cv.Point(cell.x, cell.y + cell.height), new cv.Point(cell.x + cell.width, cell.y + cell.height), new cv.Scalar(255, 0, 0, 255), 3);
                        }

                        if (c === size - 1 && !borderMap[r][c].right) { // Last col, no internal right border
                            cv.line(dst, new cv.Point(cell.x + cell.width, cell.y), new cv.Point(cell.x + cell.width, cell.y + cell.height), new cv.Scalar(0, 0, 255, 255), 3); // Blue outer
                        } else if (borderMap[r][c].right) { // Internal thick right border
                             cv.line(dst, new cv.Point(cell.x + cell.width, cell.y), new cv.Point(cell.x + cell.width, cell.y + cell.height), new cv.Scalar(255, 0, 0, 255), 3);
                        }
                    }
                }
                cv.imshow('outputCanvas', dst);


                alert("Image processing and grid reconstruction attempted. Check console for details. The KenKen grid should now be populated from the image. You can still use manual tools to modify it.");
                setBar(100, 'Import Complete!');

            } catch (error) {
                console.error("Image import failed:", error);
                alert("Image import failed. Check console for errors. This is a complex task and robust handling for all image types is difficult.");
                setBar(0, 'Import Failed!');
            } finally {
                // Proper memory cleanup for OpenCV Mats
                if (src) src.delete();
                if (gray) gray.delete();
                if (processed) processed.delete();
                if (lines) lines.delete();
                if (dst) dst.delete(); // Delete the final displayed Mat as well

                setTimeout(() => {
                    document.getElementById('progressBox').style.display = 'none';
                    document.getElementById('bar').style.width = '0%';
                    document.getElementById('bar').textContent = '';
                }, 2000);
            }
        }

        // Helper function to parse cage labels like "8+" or "3" or "1-"
        function parseCageLabel(text) {
            let target = null;
            let op = null;

            // Remove spaces
            text = text.replace(/\s/g, '');

            const ops = ['+', '-', '×', 'x', '*', '÷', '/', '=']; // Include variations

            // Try to find the operator first
            for (const operator of ops) {
                const opIndex = text.indexOf(operator);
                if (opIndex !== -1) {
                    op = operator === 'x' || operator === '*' ? '×' : (operator === '/' ? '÷' : operator); // Standardize ops
                    const numPart = text.substring(0, opIndex);
                    if (numPart !== '') {
                        target = parseInt(numPart);
                        if (isNaN(target)) target = null; // If number parsing failed
                    }
                    return { target, op };
                }
            }

            // If no explicit operator, check if it's just a number (implying '=' operator)
            const num = parseInt(text);
            if (!isNaN(num)) {
                target = num;
                op = '='; // Assume '=' operator for single number cages
            }

            return { target, op };
        }
    </script>
</body>
</html>
