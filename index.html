<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>KenKen Builder • OCR Import • Solver</title>
  <style>
    body { font-family: sans-serif; text-align: center; margin: 20px; }
    table { border-collapse: collapse; margin: 10px auto; }
    td {
      width: 50px; height: 50px;
      text-align: center; font-size: 20px; position: relative;
      cursor: pointer; padding: 0;
    }
    .selected { background: #cce5ff; }
    .cage-label {
      position: absolute;
      top: 0; left: 2px;
      font-size: 12px;
      color: #666;
    }
    .op-button {
      padding: 5px 10px;
      margin: 2px;
      font-size: 16px;
      cursor: pointer;
    }
    .op-button.selected {
      background-color: #007bff;
      color: white;
      border: none;
    }
    input[type=number] { width: 60px; }
    button { margin: 5px; padding: 5px 10px; }
    #preview { max-width: 300px; max-height: 300px; margin-top: 10px; border: 1px solid #aaa; }
    #progressBox { width: 300px; margin: 10px auto; border: 1px solid #666; height: 16px; }
    #bar { height: 100%; width: 0; background: #28a745; }
  </style>
  <script src="https://docs.opencv.org/4.x/opencv.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
</head>
<body>

<h2>KenKen Builder · Screenshot Importer · Solver</h2>

<label>Grid Size <input id="sizeInput" type="number" value="5" min="3" max="25"></label>
<button onclick="buildGrid()">Build Grid</button>

<div id="editor" style="margin-top:10px">
  <label>Target <input id="targetInput" type="number"></label>
  <span>Operator:</span>
  <button class="op-button" onclick="selectOp(this,'+')">+</button>
  <button class="op-button" onclick="selectOp(this,'-')">-</button>
  <button class="op-button" onclick="selectOp(this,'×')">×</button>
  <button class="op-button" onclick="selectOp(this,'÷')">÷</button>
  <button class="op-button" onclick="selectOp(this,'=')">=</button>
  <button onclick="addCage()">Add Cage</button>
</div>

<hr>
<h3>Import a Screenshot</h3>
<input type="file" id="imgInput" accept="image/*">
<br><img id="preview" alt="preview">
<div id="progressBox" style="display:none"><div id="bar"></div></div>
<p><button id="importBtn" disabled>Import This Image</button></p>

<table id="grid"></table>
<button onclick="solve()">Solve</button>

<script>
let cvReady = false, tessReady = false, tessWorker = null;
let size = 5, grid = [], cages = [], selectedCells = [], selectedOp = null;

cv.onRuntimeInitialized = () => {
  cvReady = true;
  checkReady();
};

(async () => {
  tessWorker = Tesseract.createWorker({ logger: m => console.log(m) });
  await tessWorker.load();
  await tessWorker.loadLanguage('eng');
  await tessWorker.initialize('eng');
  tessReady = true;
  checkReady();
})();

function checkReady() {
  if (cvReady && tessReady) {
    document.getElementById('importBtn').disabled = false;
  }
}

function buildGrid() {
  size = parseInt(document.getElementById("sizeInput").value);
  const table = document.getElementById("grid");
  table.innerHTML = '';
  cages = []; selectedCells = []; selectedOp = null; clearOpButtons(); grid = [];

  for (let r = 0; r < size; r++) {
    const tr = document.createElement("tr");
    const row = [];
    for (let c = 0; c < size; c++) {
      const td = document.createElement("td");
      td.dataset.row = r;
      td.dataset.col = c;
      td.addEventListener("click", () => toggleCell(td));
      td.textContent = '';
      td.style.border = "1px solid #444";
      tr.appendChild(td);
      row.push(td);
    }
    table.appendChild(tr);
    grid.push(row);
  }
}

function toggleCell(td) {
  const r = parseInt(td.dataset.row);
  const c = parseInt(td.dataset.col);
  const i = selectedCells.findIndex(cell => cell[0] === r && cell[1] === c);
  if (i >= 0) {
    selectedCells.splice(i, 1);
    td.classList.remove("selected");
  } else {
    selectedCells.push([r, c]);
    td.classList.add("selected");
  }
}

function selectOp(button, op) {
  selectedOp = op;
  clearOpButtons();
  button.classList.add("selected");
}

function clearOpButtons() {
  document.querySelectorAll('.op-button').forEach(btn => {
    btn.classList.remove("selected");
  });
}

function addCage() {
  const target = parseInt(document.getElementById("targetInput").value);
  if (!target || selectedCells.length === 0 || !selectedOp) return alert("Fill target, operator, and select cells");

  // Overwrite any existing cage that overlaps
  const newSet = new Set(selectedCells.map(c => c + ""));
  cages = cages.filter(c => !c.cells.some(cell => newSet.has(cell + "")));
  cages.push({ cells: [...selectedCells], target, op: selectedOp });

  selectedCells = [];
  refreshGrid();
  updateCageBorders();
}

function refreshGrid() {
  for (let r = 0; r < size; r++) {
    for (let c = 0; c < size; c++) {
      const td = grid[r][c];
      td.classList.remove("selected");
      td.textContent = "";
      td.querySelector(".cage-label")?.remove();
    }
  }
  cages.forEach((cage, index) => {
    cage.cells.forEach(([r, c], i) => {
      const td = grid[r][c];
      td.classList.add(`cage-${index}`);
      if (i === 0) {
        const label = document.createElement("div");
        label.className = "cage-label";
        label.textContent = cage.target + cage.op;
        td.appendChild(label);
      }
    });
  });
}

function getCageIndex(r, c) {
  for (let i = 0; i < cages.length; i++) {
    if (cages[i].cells.some(([x, y]) => x === r && y === c)) return i;
  }
  return null;
}

function updateCageBorders() {
  for (let r = 0; r < size; r++) {
    for (let c = 0; c < size; c++) {
      const td = grid[r][c];
      const thisCage = getCageIndex(r, c);
      if (thisCage === null) continue;

      const top = (r > 0 && getCageIndex(r - 1, c) !== thisCage) ? '2px solid black' : '1px solid #444';
      const left = (c > 0 && getCageIndex(r, c - 1) !== thisCage) ? '2px solid black' : '1px solid #444';
      const bottom = (r < size - 1 && getCageIndex(r + 1, c) !== thisCage) ? '2px solid black' : '1px solid #444';
      const right = (c < size - 1 && getCageIndex(r, c + 1) !== thisCage) ? '2px solid black' : '1px solid #444';

      td.style.borderTop = top;
      td.style.borderLeft = left;
      td.style.borderBottom = bottom;
      td.style.borderRight = right;
    }
  }
}

function solve() {
  const board = Array.from({ length: size }, () => Array(size).fill(0));

  function isValid(r, c, val) {
    for (let i = 0; i < size; i++) {
      if (board[r][i] === val || board[i][c] === val) return false;
    }

    board[r][c] = val;

    for (const cage of cages) {
      const values = cage.cells.map(([x, y]) => board[x][y]).filter(v => v !== 0);
      if (values.length === cage.cells.length) {
        const result = evaluate(values, cage.op);
        if (result !== cage.target) {
          board[r][c] = 0;
          return false;
        }
      } else if (cage.op === '=' && values[0] && values[0] !== cage.target) {
        board[r][c] = 0;
        return false;
      }
    }

    board[r][c] = 0;
    return true;
  }

  function evaluate(values, op) {
    if (op === '+') return values.reduce((a, b) => a + b, 0);
    if (op === '-') return Math.abs(values[0] - values[1]);
    if (op === '×') return values.reduce((a, b) => a * b, 1);
    if (op === '÷') return Math.max(...values) / Math.min(...values);
    if (op === '=') return values[0];
  }

  function backtrack(r = 0, c = 0) {
    if (r === size) return true;
    const [nextR, nextC] = c === size - 1 ? [r + 1, 0] : [r, c + 1];

    for (let val = 1; val <= size; val++) {
      if (isValid(r, c, val)) {
        board[r][c] = val;
        if (backtrack(nextR, nextC)) return true;
        board[r][c] = 0;
      }
    }
    return false;
  }

  if (backtrack()) {
    for (let r = 0; r < size; r++) {
      for (let c = 0; c < size; c++) {
        grid[r][c].textContent = board[r][c];
      }
    }
  } else {
    alert("No solution found.");
  }
}

// Minimal progress bar logic
function setBar(pct) {
  document.getElementById('progressBox').style.display = 'block';
  document.getElementById('bar').style.width = pct + '%';
}

// TODO: Add image processing & OCR here.

document.getElementById('imgInput').onchange = e => {
  const file = e.target.files[0];
  if (!file) return;
  const preview = document.getElementById('preview');
  preview.src = URL.createObjectURL(file);
  preview.onload = () => URL.revokeObjectURL(preview.src);
};

</script>
</body>
</html>
