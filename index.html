<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KenKen Builder • OCR Import • Solver</title>
    <style>
        body { font-family: sans-serif; text-align: center; margin: 20px; background-color: #f4f4f4; color: #333; }
        h2 { color: #0056b3; }
        table { border-collapse: collapse; margin: 10px auto; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        td {
            width: 50px; height: 50px;
            text-align: center; font-size: 20px; position: relative;
            cursor: pointer; padding: 0;
            box-sizing: border-box; /* Include padding/border in width/height */
            background-color: #fff;
        }
        .selected { background-color: #cce5ff; border: 2px solid #007bff !important; } /* Important to override border */
        .cage-label {
            position: absolute;
            top: 2px; left: 4px; /* Adjusted for better visibility */
            font-size: 11px; /* Slightly smaller for clarity */
            color: #666;
            pointer-events: none; /* Allow clicks to pass through to cell */
            z-index: 1; /* Ensure label is above content */
            font-weight: bold;
        }
        .op-button {
            padding: 8px 15px; /* Larger clickable area */
            margin: 5px;
            font-size: 16px;
            cursor: pointer;
            border: 1px solid #007bff;
            border-radius: 5px;
            background-color: #e7f5ff;
            color: #007bff;
            transition: all 0.2s ease-in-out;
        }
        .op-button:hover {
            background-color: #007bff;
            color: white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .op-button.selected {
            background-color: #007bff;
            color: white;
            border: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        input[type=number] {
            width: 70px; /* Slightly wider */
            padding: 8px;
            margin: 5px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        button {
            padding: 10px 20px;
            margin: 8px;
            font-size: 17px;
            cursor: pointer;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        button:hover:not([disabled]) {
            background-color: #218838;
            box-shadow: 0 4px 8px rgba(0,0,0,0.25);
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            box-shadow: none;
        }
        #preview, #outputCanvas {
            max-width: 90%; /* Responsive max-width */
            height: auto; /* Maintain aspect ratio */
            margin-top: 15px;
            border: 1px solid #aaa;
            display: block;
            margin-left: auto;
            margin-right: auto;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.15);
        }
        #progressBox {
            width: 90%; /* Responsive width */
            max-width: 300px; /* Max width for larger screens */
            margin: 15px auto;
            border: 1px solid #666;
            height: 20px; /* Taller progress bar */
            position: relative;
            background-color: #e0e0e0;
            border-radius: 10px;
            overflow: hidden; /* Ensure bar stays within bounds */
        }
        #bar {
            height: 100%;
            width: 0;
            background: linear-gradient(to right, #28a745, #4CAF50); /* Gradient for visual appeal */
            text-align: center;
            color: white;
            font-size: 12px;
            line-height: 20px;
            transition: width 0.3s ease-out; /* Smooth progress animation */
            border-radius: 10px 0 0 10px; /* Rounded corners only on the left */
        }
        #libraryStatus {
            margin: 15px auto;
            font-weight: bold;
            color: #0056b3;
            padding: 10px;
            border: 1px solid #b3d9ff;
            background-color: #e6f2ff;
            border-radius: 8px;
            max-width: 400px;
        }
        hr { border: 0; height: 1px; background-image: linear-gradient(to right, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.75), rgba(0, 0, 0, 0)); margin: 30px auto; width: 80%; }
    </style>
    <!-- Tesseract.js library (main script) - USING V3.0.3 -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@3.0.3/dist/tesseract.min.js"></script>
</head>
<body>

    <h2>KenKen Builder · Screenshot Importer · Solver</h2>

    <p id="libraryStatus">Loading essential libraries (OpenCV, Tesseract)...</p>

    <label>Grid Size <input id="sizeInput" type="number" value="6" min="3" max="25"></label>
    <button onclick="buildGrid()">Build Grid</button>

    <div id="editor" style="margin-top:10px">
        <label>Target <input id="targetInput" type="number"></label>
        <span>Operator:</span>
        <button class="op-button" onclick="selectOp(this,'+')">+</button>
        <button class="op-button" onclick="selectOp(this,'-')">-</button>
        <button class="op-button" onclick="selectOp(this,'×')">×</button>
        <button class="op-button" onclick="selectOp(this,'÷')">÷</button>
        <button class="op-button" onclick="selectOp(this,'=')">=</button>
        <button onclick="addCage()">Add Cage</button>
    </div>

    <hr>
    <h3>Import a Screenshot</h3>
    <input type="file" id="imgInput" accept="image/*">
    <br><img id="preview" alt="Image Preview">
    <canvas id="outputCanvas"></canvas> <!-- Added canvas for OpenCV output -->
    <div id="progressBox" style="display:none"><div id="bar"></div></div>
    <p><button id="importBtn" disabled onclick="importImage()">Import This Image</button></p>

    <table id="grid"></table>
    <button onclick="solve()">Solve</button>

    <script>
        // --- OpenCV.js Initialization: Global Module object for dynamic loading ---
        let cvReadyPromiseResolver;
        let cvRuntimeInitializedPromise = new Promise((resolve, reject) => {
            cvReadyPromiseResolver = { resolve, reject }; // Store both resolve and reject
        });

        // Define the Module object for OpenCV.js in the global scope.
        // This MUST be defined before the opencv.js script is loaded.
        var Module = {
            onRuntimeInitialized: function() {
                console.log("OpenCV (Module.onRuntimeInitialized) is ready!");
                cvReadyPromiseResolver.resolve(); // Resolve the promise indicating OpenCV is ready
            }
        };

        // Dynamically load OpenCV.js script.
        // This ensures the Module object is defined first and then the script is fetched.
        (function loadOpenCvScript() {
            const script = document.createElement('script');
            // FIX: Reverted to a known good, official CDN link for OpenCV.js 4.7.0 for stability.
            script.src = "https://docs.opencv.org/4.7.0/opencv.js"; 
            script.async = true; // Load asynchronously
            script.onerror = (e) => {
                console.error("Failed to load OpenCV.js script:", e);
                // Explicitly reject the promise if the script tag fails to load
                cvReadyPromiseResolver.reject(new Error(`Failed to load OpenCV.js script from CDN. Event: ${JSON.stringify(e)}. Check network/browser console for details.`));
            };
            document.head.appendChild(script);
        })();


        let tessReadyPromiseResolver;
        let tessWorkerInitializedPromise = new Promise(resolve => {
            tessReadyPromiseResolver = resolve;
        });

        let tessWorker = null;
        let size = 6, grid = [], cages = [], selectedCells = [], selectedOp = null;
        let initialBoardState = [];
        let selectedFile = null; // Store the file object globally

        // --- Library Initialization wrapped in DOMContentLoaded ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOMContentLoaded fired. Starting library initialization.");

            // Tesseract worker initialization
            (async () => {
                try {
                    tessWorker = Tesseract.createWorker(
                        'eng', // 1st argument: langs (language)
                        null,  // 2nd argument: oem (OCR Engine Mode - null for default)
                        {      // 3rd argument: options object
                            workerPath: 'https://cdn.jsdelivr.net/npm/tesseract.js@3.0.3/dist/worker.min.js',
                            corePath: 'https://cdn.jsdelivr.net/npm/tesseract.js@3.0.3/dist/tesseract-core.js', // Note: .js for v3 core
                            langPath: 'https://cdn.jsdelivr.net/npm/tessdata@3.0.3/', // Base URL for language data files
                            logger: m => {
                                console.log('Tesseract Log:', m); // Logs all internal Tesseract messages
                                if (m.status) {
                                    // Update main page status to reflect Tesseract's internal progress
                                    document.getElementById('libraryStatus').textContent = `Tesseract: ${m.status.replace(/_/g, ' ')} (${Math.round(m.progress * 100)}%)`;
                                }
                            },
                            worker: false // IMPORTANT: Disable Web Worker - all OCR runs on main thread
                        }
                    );

                    // This guard is crucial to catch if Tesseract.createWorker itself fails
                    if (!tessWorker || typeof tessWorker.load !== 'function') {
                        throw new Error("Tesseract.createWorker() did not return a valid worker object. Tesseract.js core initialization failed. Please check setup.");
                    }

                    await tessWorker.load();
                    await tessWorker.loadLanguage('eng');
                    await tessWorker.initialize('eng');
                    console.log("Tesseract is ready!");
                    tessReadyPromiseResolver();

                } catch (error) {
                    console.error("Failed to initialize Tesseract:", error);
                    document.getElementById('libraryStatus').textContent = "Error loading Tesseract. Check console & network for details.";
                    alert("Error loading Tesseract. Please check your internet connection or console for details.");
                    document.getElementById('importBtn').disabled = true; // Disable import button on Tesseract failure
                }
            })();

            // --- Centralized Readiness Check & App Start ---
            Promise.all([cvRuntimeInitializedPromise, tessWorkerInitializedPromise])
                .then(() => {
                    console.log("All essential libraries (OpenCV, Tesseract) are ready!");
                    document.getElementById('importBtn').disabled = false;
                    document.getElementById('libraryStatus').textContent = "Libraries loaded successfully. Ready to build or import!";
                    buildGrid(); // Build the initial grid only after libraries are ready
                })
                .catch(error => {
                    console.error("One or more libraries failed to load:", error);
                    document.getElementById('libraryStatus').textContent = "Failed to load all libraries. Functionality limited.";
                    alert("Error: Essential libraries could not be loaded. Some features may not work. Check console.");
                });
        }); // End of DOMContentLoaded listener


        // --- KenKen Builder (Manual Input) Logic ---
        function buildGrid() {
            size = parseInt(document.getElementById("sizeInput").value);
            const table = document.getElementById("grid");
            table.innerHTML = '';
            cages = []; selectedCells = [], selectedOp = null; clearOpButtons();
            grid = [];
            initialBoardState = Array(size).fill(0).map(() => Array(size).fill(0));

            for (let r = 0; r < size; r++) {
                const tr = document.createElement("tr");
                const row = [];
                for (let c = 0; c < size; c++) {
                    const td = document.createElement("td");
                    td.dataset.row = r;
                    td.dataset.col = c;
                    td.addEventListener("click", () => toggleCell(td));
                    td.textContent = '';
                    tr.appendChild(td);
                    row.push(td);
                }
                table.appendChild(tr);
                grid.push(row);
            }
            refreshGrid();
        }

        function toggleCell(td) {
            const r = parseInt(td.dataset.row);
            const c = parseInt(td.dataset.col);
            const i = selectedCells.findIndex(cell => cell[0] === r && cell[1] === c);
            if (i >= 0) {
                selectedCells.splice(i, 1);
                td.classList.remove("selected");
            } else {
                selectedCells.push([r, c]);
                td.classList.add("selected");
            }
        }

        function selectOp(button, op) {
            selectedOp = op;
            clearOpButtons();
            button.classList.add("selected");
        }

        function clearOpButtons() {
            document.querySelectorAll('.op-button').forEach(btn => {
                btn.classList.remove("selected");
            });
        }

        function addCage() {
            const targetInput = document.getElementById("targetInput").value;
            const target = parseInt(targetInput);

            if (selectedCells.length === 0) {
                alert("Please select cells for the cage.");
                return;
            }
            if (!selectedOp) {
                alert("Please select an operator.");
                return;
            }
            if (selectedOp !== '=' && (!targetInput || isNaN(target))) {
                alert("Please enter a valid target number for the cage, or select '=' for single-cell cages.");
                return;
            }

            const currentCageCells = [...selectedCells];

            const newSet = new Set(currentCageCells.map(c => c + ""));
            cages = cages.filter(c => !c.cells.some(cell => newSet.has(cell + "")));

            currentCageCells.sort((a, b) => a[0] - b[0] || a[1] - b[1]);

            cages.push({ cells: currentCageCells, target: targetInput, op: selectedOp });

            selectedCells = [];
            document.getElementById("targetInput").value = '';
            clearOpButtons();
            selectedOp = null;
            refreshGrid();
        }

        function refreshGrid() {
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    const td = grid[r][c];
                    td.classList.remove("selected");
                    td.textContent = initialBoardState[r][c] !== 0 ? initialBoardState[r][c] : '';
                    td.querySelector(".cage-label")?.remove();
                    td.style.border = "1px solid #444";
                }
            }

            cages.forEach((cage) => {
                if (cage.cells.length > 0) {
                    const [topmostR, leftmostC] = cage.cells.reduce((minCell, currentCell) => {
                        if (currentCell[0] < minCell[0]) return currentCell;
                        if (currentCell[0] === minCell[0] && currentCell[1] < minCell[1]) return currentCell;
                        return minCell;
                    }, cage.cells[0]);

                    const td = grid[topmostR][leftmostC];
                    let label = td.querySelector(".cage-label");
                    if (!label) {
                        label = document.createElement("div");
                        label.className = "cage-label";
                        td.appendChild(label);
                    }
                    label.textContent = cage.target + cage.op;
                }
            });
            updateCageBorders();
        }

        function getCageIndex(r, c) {
            for (let i = 0; i < cages.length; i++) {
                if (cages[i].cells.some(([x, y]) => x === r && y === c)) return i;
            }
            return null;
        }

        function updateCageBorders() {
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    const td = grid[r][c];
                    const thisCage = getCageIndex(r, c);

                    td.style.borderTop = '1px solid #444';
                    td.style.borderLeft = '1px solid #444';
                    td.style.borderBottom = '1px solid #444';
                    td.style.borderRight = '1px solid #444';

                    if (thisCage === null) {
                        continue;
                    }

                    const top = (r > 0 && getCageIndex(r - 1, c) !== thisCage) ? '2px solid black' : '1px solid #444';
                    const left = (c > 0 && getCageIndex(r, c - 1) !== thisCage) ? '2px solid black' : '1px solid #444';
                    const bottom = (r < size - 1 && getCageIndex(r + 1, c) !== thisCage) ? '2px solid black' : '1px solid #444';
                    const right = (c < size - 1 && getCageIndex(r, c + 1) !== thisCage) ? '2px solid black' : '1px solid #444';

                    td.style.borderTop = top;
                    td.style.borderLeft = left;
                    td.style.borderBottom = bottom;
                    td.style.borderRight = right;
                }
            }
        }

        // --- KenKen Solver Logic ---
        function solve() {
            const board = initialBoardState.map(row => [...row]);

            function isValid(r, c, val) {
                for (let i = 0; i < size; i++) {
                    if (board[r][i] === val || board[i][c] === val) return false;
                }

                board[r][c] = val;

                for (const cage of cages) {
                    const isCellInCage = cage.cells.some(([cx, cy]) => cx === r && cy === c);
                    if (!isCellInCage) continue;

                    const valuesInCage = cage.cells.map(([x, y]) => board[x][y]).filter(v => v !== 0);

                    if (valuesInCage.length === cage.cells.length) {
                        const result = evaluate(valuesInCage, cage.op);
                        if (result === null || result !== parseInt(cage.target)) {
                            board[r][c] = 0;
                            return false;
                        }
                    } else {
                        if (cage.op === '=' && valuesInCage.length === 1 && valuesInCage[0] !== parseInt(cage.target)) {
                            board[r][c] = 0; return false;
                        }
                        if (cage.op === '+' && valuesInCage.reduce((a, b) => a + b, 0) > parseInt(cage.target)) {
                            board[r][c] = 0; return false;
                        }
                        if (cage.op === '×' && valuesInCage.reduce((a, b) => a * b, 1) > parseInt(cage.target)) {
                            board[r][c] = 0; return false;
                        }
                    }
                }

                board[r][c] = 0;
                return true;
            }

            function evaluate(values, op) {
                values = values.map(Number);

                if (op === '+') return values.reduce((a, b) => a + b, 0);
                if (op === '-') {
                    if (values.length === 2) return Math.abs(values[0] - values[1]);
                    return null;
                }
                if (op === '×') return values.reduce((a, b) => a * b, 1);
                if (op === '÷') {
                    if (values.length === 2) {
                        const maxVal = Math.max(...values);
                        const minVal = Math.min(...values);
                        if (minVal === 0 || maxVal % minVal !== 0) return null;
                        return maxVal / minVal;
                    }
                    return null;
                }
                if (op === '=') return values[0];
                return null;
            }

            function backtrack(r = 0, c = 0) {
                while (r < size && board[r][c] !== 0) {
                    if (c === size - 1) {
                        r++;
                        c = 0;
                    } else {
                        c++;
                    }
                }

                if (r === size) return true;

                for (let val = 1; val <= size; val++) {
                    if (isValid(r, c, val)) {
                        board[r][c] = val;
                        if (backtrack(r, c)) return true;
                        board[r][c] = 0;
                    }
                }
                return false;
            }

            if (backtrack()) {
                for (let r = 0; r < size; r++) {
                    for (let c = 0; c < size; c++) {
                        grid[r][c].textContent = board[r][c];
                    }
                }
                alert("Solution found!");
            } else {
                alert("No solution found for this KenKen puzzle.");
            }
        }

        // --- Image Import and Processing Logic (OCR Input) ---
        function setBar(pct, message = '') {
            const progressBox = document.getElementById('progressBox');
            const bar = document.getElementById('bar');
            progressBox.style.display = 'block';
            bar.style.width = pct + '%';
            bar.textContent = message;
        }

        document.getElementById('imgInput').onchange = e => {
            const file = e.target.files[0];
            if (!file) {
                selectedFile = null;
                return;
            }
            selectedFile = file; // Store the file object
            const preview = document.getElementById('preview');
            preview.src = URL.createObjectURL(file);
            preview.onload = () => {
                // The Blob URL for the preview image is now managed directly by importImage
                // where it's revoked after cv.imread uses the raw bytes.
            };
        };

        async function importImage() {
            const imgElement = document.getElementById('preview');
            if (!selectedFile) { // Check if a file was actually selected
                alert("Please select an image first for import.");
                return;
            }

            // Show UI elements for progress
            document.getElementById('progressBox').style.display = 'block';
            document.getElementById('outputCanvas').style.display = 'block';

            let src = null, gray = null, processed = null, lines = null, dst = null; // Declare Mats for cleanup

            try {
                setBar(5, 'Loading image into canvas...');

                // Create a temporary canvas to draw the image for cv.imread
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');

                // Wait for the image to load on the imgElement
                await new Promise((resolve, reject) => {
                    if (imgElement.complete && imgElement.naturalWidth !== 0) { // Already loaded
                        resolve();
                    } else {
                        imgElement.onload = () => resolve();
                        imgElement.onerror = () => reject(new Error("Image failed to load onto imgElement."));
                    }
                });

                // Set canvas dimensions to match the image
                tempCanvas.width = imgElement.naturalWidth;
                tempCanvas.height = imgElement.naturalHeight;

                // Draw the image onto the temporary canvas
                tempCtx.drawImage(imgElement, 0, 0, tempCanvas.width, tempCanvas.height);

                // Use cv.imread directly from the canvas
                src = cv.imread(tempCanvas);

                // Clean up the temporary canvas
                tempCanvas.remove();

                // Revoke the Blob URL from the preview img element
                if (imgElement.src && imgElement.src.startsWith('blob:')) {
                    URL.revokeObjectURL(imgElement.src);
                    imgElement.src = ""; // Clear src to prevent re-using invalid URL
                }


                setBar(10, 'Applying adaptive threshold...');
                gray = new cv.Mat();
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);

                processed = new cv.Mat();
                cv.adaptiveThreshold(gray, processed, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 2);

                setBar(20, 'Detecting lines (Hough Transform)...');
                lines = new cv.Mat();
                cv.HoughLinesP(processed, lines, 1, Math.PI / 180, 50, 40, 5);

                setBar(30, 'Clustering grid lines...');
                let horizontalLines = [];
                let verticalLines = [];
                const angleTolerance = 5 * Math.PI / 180;
                const lineClusteringTolerance = 10;

                for (let i = 0; i < lines.rows; ++i) {
                    let x1 = lines.data32S[i * 4];
                    let y1 = lines.data32S[i * 4 + 1];
                    let x2 = lines.data32S[i * 4 + 2];
                    let y2 = lines.data32S[i * 4 + 3];

                    let angle = Math.atan2(y2 - y1, x2 - x1);

                    if (Math.abs(angle) < angleTolerance || Math.abs(angle - Math.PI) < angleTolerance) {
                        horizontalLines.push(Math.round((y1 + y2) / 2));
                    } else if (Math.abs(angle - Math.PI / 2) < angleTolerance || Math.abs(angle + Math.PI / 2) < angleTolerance) {
                        verticalLines.push(Math.round((x1 + x2) / 2));
                    }
                }

                function clusterLines(linePositions, tolerance) {
                    linePositions.sort((a, b) => a - b);
                    let clustered = [];
                    if (linePositions.length === 0) return clustered;

                    let currentCluster = [linePositions[0]];
                    for (let i = 1; i < linePositions.length; i++) {
                        if (linePositions[i] - currentCluster[currentCluster.length - 1] < tolerance) {
                            currentCluster.push(linePositions[i]);
                        } else {
                            clustered.push(Math.round(currentCluster.reduce((a, b) => a + b, 0) / currentCluster.length));
                            currentCluster = [linePositions[i]];
                        }
                    }
                    clustered.push(Math.round(currentCluster.reduce((a, b) => a + b, 0) / currentCluster.length));
                    return clustered;
                }

                let uniqueH = clusterLines(horizontalLines, lineClusteringTolerance);
                let uniqueV = clusterLines(verticalLines, lineClusteringTolerance);

                console.log("Detected Horizontal Lines (Y-coords):", uniqueH);
                console.log("Detected Vertical Lines (X-coords):", uniqueV);

                if (uniqueH.length < 2 || uniqueV.length < 2) {
                    throw new Error("Could not detect enough grid lines. Ensure image is clear and well-aligned.");
                }
                const detectedSize = Math.min(uniqueH.length - 1, uniqueV.length - 1);
                if (detectedSize < 3 || detectedSize > 25) {
                    throw new Error(`Detected grid size ${detectedSize} is out of typical KenKen range (3-25).`);
                }
                size = detectedSize;
                document.getElementById('sizeInput').value = size;

                cages = [];
                initialBoardState = Array(size).fill(0).map(() => Array(size).fill(0));


                setBar(40, 'Mapping cell coordinates...');
                const cellCoords = [];
                for (let r = 0; r < size; r++) {
                    for (let c = 0; c < size; c++) {
                        const x1 = uniqueV[c];
                        const y1 = uniqueH[r];
                        const x2 = uniqueV[c + 1];
                        const y2 = uniqueH[r + 1];
                        cellCoords.push({ r, c, x: x1, y: y1, width: x2 - x1, height: y2 - y1 });
                    }
                }

                setBar(50, 'Analyzing cell borders...');
                const borderMap = Array(size).fill(0).map(() => Array(size).fill(0).map(() => ({
                    top: false, bottom: false, left: false, right: false
                })));

                const lineDensityThreshold = 0.5;
                const lineCheckWidth = 5;

                for (let r = 0; r < size; r++) {
                    for (let c = 0; c < size; c++) {
                        const cell = cellCoords.find(coord => coord.r === r && coord.c === c);
                        if (!cell) continue;

                        const checkLineSegment = (x_start, y_start, x_end, y_end, isHorizontal) => {
                            let linePixels = 0;
                            let totalPixels = 0;

                            if (isHorizontal) {
                                for (let x = x_start; x < x_end; x++) {
                                    for (let dy = -Math.floor(lineCheckWidth/2); dy <= Math.ceil(lineCheckWidth/2); dy++) {
                                        const checkY = y_start + dy;
                                        if (checkY >= 0 && checkY < processed.rows && x >= 0 && x < processed.cols) {
                                            totalPixels++;
                                            if (processed.data[checkY * processed.cols + x] === 255) {
                                                linePixels++;
                                            }
                                        }
                                    }
                                }
                            } else {
                                for (let y = y_start; y < y_end; y++) {
                                    for (let dx = -Math.floor(lineCheckWidth/2); dx <= Math.ceil(lineCheckWidth/2); dx++) {
                                        const checkX = x_start + dx;
                                        if (checkX >= 0 && checkX < processed.cols && y >= 0 && y < processed.rows) {
                                            totalPixels++;
                                            if (processed.data[y * processed.cols + checkX] === 255) {
                                                linePixels++;
                                            }
                                        }
                                    }
                                }
                            }
                            return totalPixels > 0 ? (linePixels / totalPixels) : 0;
                        };

                        if (r > 0) {
                            const density = checkLineSegment(cell.x, cell.y, cell.x + cell.width, cell.y, true);
                            if (density > lineDensityThreshold) {
                                borderMap[r][c].top = true;
                                borderMap[r-1][c].bottom = true;
                            }
                        }

                        if (c > 0) {
                            const density = checkLineSegment(cell.x, cell.y, cell.x, cell.y + cell.height, false);
                            if (density > lineDensityThreshold) {
                                borderMap[r][c].left = true;
                                borderMap[r][c-1].right = true;
                            }
                        }
                    }
                }
                console.log("Border Map (derived from pixel density):", borderMap);

                setBar(70, 'Performing OCR on image...');
                // The actual OCR step - this is where the lag might occur
                // Pass the image element, as Tesseract.js can work directly with it after it's rendered
                const { data: { words: allWords } } = await tessWorker.recognize(imgElement);
                console.log("All Recognized Words with BBoxes:", allWords);

                setBar(80, 'Mapping OCR results to grid cells...');
                const cellContents = Array(size).fill(0).map(() => Array(size).fill(0).map(() => ({ labels: [], numbers: [] })));

                for (const word of allWords) {
                    const wordRect = word.bbox;
                    for (const cell of cellCoords) {
                        const wordCenterX = wordRect.x0 + wordRect.width / 2;
                        const wordCenterY = wordRect.y0 + wordRect.height / 2;

                        if (wordCenterX >= cell.x && wordCenterX <= cell.x + cell.width &&
                            wordCenterY >= cell.y && wordCenterY <= cell.y + cell.height) {

                            const parsed = parseCageLabel(word.text.trim());
                            const num = parseInt(word.text.trim());

                            if (parsed.op && (parsed.target !== null || parsed.op === '=')) {
                                cellContents[cell.r][cell.c].labels.push({ text: word.text.trim(), parsed: parsed, bbox: wordRect });
                            }
                            if (!isNaN(num) && num >= 1 && num <= size && !parsed.op) {
                                initialBoardState[cell.r][cell.c] = num;
                            }
                            break;
                        }
                    }
                }
                console.log("Cell Contents (from OCR mapping):", cellContents);

                setBar(90, 'Reconstructing cages...');
                const visitedCellsForCages = Array(size).fill(false).map(() => Array(size).fill(false));
                cages = [];

                function floodFillForCage(startR, startC, borderMap, visited) {
                    const cageCells = [];
                    const queue = [[startR, startC]];
                    visited[startR][startC] = true;

                    while (queue.length > 0) {
                        const [currR, currC] = queue.shift();
                        cageCells.push([currR, currC]);

                        const neighbors = [
                            { dr: -1, dc: 0, dir: 'top' },
                            { dr: 1, dc: 0, dir: 'bottom' },
                            { dr: 0, dc: -1, dir: 'left' },
                            { dr: 0, dc: 1, dir: 'right' }
                        ];

                        for (const { dr, dc, dir } of neighbors) {
                            const nr = currR + dr;
                            const nc = currC + dc;

                            if (nr >= 0 && nr < size && nc >= 0 && nc < size && !visited[nr][nc]) {
                                const hasBorder = borderMap[currR][currC][dir];

                                if (!hasBorder) {
                                    queue.push([nr, nc]);
                                    visited[nr][nc] = true;
                                }
                            }
                        }
                    }
                    return cageCells;
                }

                for (let r = 0; r < size; r++) {
                    for (let c = 0; c < size; c++) {
                        if (cellContents[r][c].labels.length > 0 && !visitedCellsForCages[r][c]) {
                            const label = cellContents[r][c].labels[0];
                            const { target: cageTarget, op: cageOp } = label.parsed;

                            if (cageTarget !== null || cageOp === '=') {
                                const cellsInThisCage = floodFillForCage(r, c, borderMap, visitedCellsForCages);

                                if (cellsInThisCage.length > 0) {
                                    cellsInThisCage.sort((a, b) => a[0] - b[0] || a[1] - b[1]);
                                    cages.push({ cells: cellsInThisCage, target: cageTarget, op: cageOp });
                                }
                            }
                        }
                    }
                }
                console.log("Reconstructed Cages (robust):", cages);
                console.log("Initial Board State (from OCR numbers):", initialBoardState);

                const currentSizeVal = size;
                const currentCages = [...cages];
                const currentInitialBoardState = initialBoardState.map(row => [...row]);

                document.getElementById('sizeInput').value = currentSizeVal;
                buildGrid();

                size = currentSizeVal;
                cages = currentCages;
                initialBoardState = currentInitialBoardState;

                refreshGrid();

                // To display processed image on canvas:
                const outputCanvas = document.getElementById('outputCanvas');
                if (outputCanvas) {
                    outputCanvas.width = src.cols;
                    outputCanvas.height = src.rows;
                    dst = src.clone(); 
                } else {
                    dst = new cv.Mat.zeros(src.rows, src.cols, src.type()); 
                }


                for (let i = 0; i < uniqueH.length; i++) {
                    cv.line(dst, new cv.Point(uniqueV[0], uniqueH[i]), new cv.Point(uniqueV[uniqueV.length - 1], uniqueH[i]), new cv.Scalar(0, 255, 0, 255), 1);
                }
                for (let i = 0; i < uniqueV.length; i++) {
                    cv.line(dst, new cv.Point(uniqueV[i], uniqueH[0]), new cv.Point(uniqueV[i], uniqueH[uniqueH.length - 1]), new cv.Scalar(0, 255, 0, 255), 1);
                }
                for (let r = 0; r < size; r++) {
                    for (let c = 0; c < size; c++) {
                        const cell = cellCoords.find(coord => coord.r === r && coord.c === c);
                        if (!cell) continue;

                        if (borderMap[r][c].top) {
                            cv.line(dst, new cv.Point(cell.x, cell.y), new cv.Point(cell.x + cell.width, cell.y), new cv.Scalar(255, 0, 0, 255), 3);
                        }
                        if (borderMap[r][c].left) {
                            cv.line(dst, new cv.Point(cell.x, cell.y), new cv.Point(cell.x, cell.y + cell.height), new cv.Scalar(255, 0, 0, 255), 3);
                        }
                        if (r === size - 1 && !borderMap[r][c].bottom) {
                            cv.line(dst, new cv.Point(cell.x, cell.y + cell.height), new cv.Point(cell.x + cell.width, cell.y + cell.height), new cv.Scalar(0, 0, 255, 255), 3);
                        } else if (borderMap[r][c].bottom) {
                            cv.line(dst, new cv.Point(cell.x, cell.y + cell.height), new cv.Point(cell.x + cell.width, cell.y + cell.height), new cv.Scalar(255, 0, 0, 255), 3);
                        }

                        if (c === size - 1 && !borderMap[r][c].right) {
                            cv.line(dst, new cv.Point(cell.x + cell.width, cell.y), new cv.Point(cell.x + cell.width, cell.y + cell.height), new cv.Scalar(0, 0, 255, 255), 3);
                        } else if (borderMap[r][c].right) {
                             cv.line(dst, new cv.Point(cell.x + cell.width, cell.y), new cv.Point(cell.x + cell.width, cell.y + cell.height), new cv.Scalar(255, 0, 0, 255), 3);
                        }
                    }
                }
                cv.imshow('outputCanvas', dst);


                alert("Image processing and grid reconstruction attempted. Check console for details. The KenKen grid should now be populated from the image. You can still use manual tools to modify it.");
                setBar(100, 'Import Complete!');

            } catch (error) {
                console.error("Image import failed:", error);
                alert("Image import failed. Check console for errors. This is a complex task and robust handling for all image types is difficult.");
                setBar(0, 'Import Failed!');
            } finally {
                if (src) src.delete();
                if (gray) gray.delete();
                if (processed) processed.delete();
                if (lines) lines.delete();
                if (dst) dst.delete();

                setTimeout(() => {
                    document.getElementById('progressBox').style.display = 'none';
                    document.getElementById('bar').style.width = '0%';
                    document.getElementById('bar').textContent = '';
                }, 2000);
            }
        }

        function parseCageLabel(text) {
            let target = null;
            let op = null;

            text = text.replace(/\s/g, '');

            const ops = ['+', '-', '×', 'x', '*', '÷', '/', '='];

            for (const operator of ops) {
                const opIndex = text.indexOf(operator);
                if (opIndex !== -1) {
                    op = operator === 'x' || operator === '*' ? '×' : (operator === '/' ? '÷' : operator);
                    const numPart = text.substring(0, opIndex);
                    if (numPart !== '') {
                        target = parseInt(numPart);
                        if (isNaN(target)) target = null;
                    }
                    return { target, op };
                }
            }

            const num = parseInt(text);
            if (!isNaN(num)) {
                target = num;
                op = '=';
            }

            return { target, op };
        }
    </script>
</body>
</html>
